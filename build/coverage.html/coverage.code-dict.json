{"/home/travis/build/npmtest/node-npmtest-torrent-cloud/test.js":"/* istanbul instrument in package npmtest_torrent_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/lib.npmtest_torrent_cloud.js":"/* istanbul instrument in package npmtest_torrent_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_torrent_cloud = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_torrent_cloud = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-torrent-cloud && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_torrent_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_torrent_cloud\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_torrent_cloud.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_torrent_cloud.rollup.js'] =\n            local.assetsDict['/assets.npmtest_torrent_cloud.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_torrent_cloud.__dirname + '/lib.npmtest_torrent_cloud.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/server.js":"//load server config\nvar config = require(\"./config.json\");\n//apply defaults from env\nfor(var k in config) {\n\tif(k in process.env) {\n\t\tconfig[k] = process.env[k];\n\t}\n}\n\n//load submodules\nvar search = require(\"./lib/search\");\nvar torrents = require(\"./lib/torrents\");\nvar backend = require(\"./lib/backend\");\nvar ws = require(\"./lib/ws\");\n\nvar basicAuth = require('basic-auth-connect');\nvar bodyParser = require('body-parser');\n\nvar http = require('http');\nvar express = require('express');\nvar app = express();\nvar server = http.createServer(app);\nvar port = parseInt(process.argv[2], 10) ||\n\t\t\tprocess.env.PORT || \n\t\t\tprocess.env.OPENSHIFT_NODEJS_PORT || \n\t\t\t3000;\nvar host = process.env.HOST ||\n\t\t\tprocess.env.OPENSHIFT_NODEJS_IP ||\n\t\t\t\"0.0.0.0\";\n\n//global auth\nvar user = process.env.AUTH_USER || 'admin';\nvar password = process.env.AUTH_PASSWORD;\nif(password)\n\tapp.use(basicAuth(user, password));\n\n//hook http server\nws.install(server);\n\n//all requests have JSON body\napp.use(bodyParser.json());\n\n//convert all of the given module's\n//exposed functions into API endpoints\nfunction api(name, module) {\n\tObject.keys(module).forEach(function(key) {\n\t\tvar fn = module[key];\n\t\tif(typeof fn !== \"function\")\n\t\t\treturn;\n\t\t//dont call modules with request/response,\n\t\t//instead call with 'body' and 'callback(err, data)'\n\t\tvar endpoint = '/api/'+name+'/'+key;\n\t\t// console.log(\"POST %s -> %s.%s\", endpoint, name, key);\n\t\tapp.post(endpoint, function (req, res) {\n\t\t\tfn(req.body, function(err, data) {\n\t\t\t\tif(err) {\n\t\t\t\t\tres.status(400).send(err);\n\t\t\t\t} else {\n\t\t\t\t\tres.send(data || \"OK\");\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\n\n//use all module methods as JSON POST endpoints\napi('search', search);\napi('torrents', torrents);\n\n//TODO(@jpillora) in future, some storage backends may need\n//custom APIs\n\n//disallow crawling\napp.get('/robots.txt', function(req, res) {\n\tres.send(\"User-agent: *\\nDisallow: /\");\n});\n\n//modify configuration\n// app.post('/config', function(req, res) {\n// \tif(!req.body)\n// \t\treturn res.status(400).send(\"No body\");\n// \tvar changed = false;\n// \tfor(var k in req.body) {\n// \t\tvar v = req.body[k];\n// \t\tif(k in config && config[k] !== v) {\n// \t\t\tconfig[k] = v;\n// \t\t\tchanged = true;\n// \t\t}\n// \t}\n// \tif(changed) {\n// \t\tupdate();\n// \t}\n// });\n\n//expose static files\napp.use('/', express.static(__dirname + '/static'));\n\nvar storedFiles = {};\n\n//broadcast state on \"update\"\nvar update = function(newFiles) {\n\t//optionally update stored files\n\tif(newFiles)\n\t\tstoredFiles = newFiles;\n\t//broadcast state\n\tws.broadcast({\n\t\tconfig: config,\n\t\tproviders: search.providers,\n\t\ttorrents: torrents.list,\n\t\tfilesDownloading: torrents.filesDownloading,\n\t\tuploads: storedFiles\n\t});\n};\nsearch.on(\"update\", update);\ntorrents.on(\"update\", update);\n\n//periodically scan for new stored files\nfunction list() {\n\tbackend.list(function(err, files) {\n\t\tif(!err) update(files);\n\t});\n}\nsetInterval(list, 15*60*1000);\nlist();\n\nserver.on(\"error\", function(err) {\n\tswitch(err.code) {\n\t\tcase \"EADDRINUSE\":\n\t\t\tconsole.error(\"Port %s is currently in use\", port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.error(\"Failed to listen on %s:%s (%s)\", host, port, err.toString());\n\t}\n\tprocess.exit(1);\n});\n\n//listen!\nserver.listen(port, host, function() {\n\tconsole.log(\"listening on %s:%s...\", host, port);\n});\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/search.js":"\nvar events = require('events');\nvar search = module.exports = new events.EventEmitter();\n\nvar types = {\n\t\"screen-scraper\": require(\"./searchers/screen-scraper\"),\n\t\"json-api\": require(\"./searchers/json-api\")\n};\n\nvar providers = {};\nsearch.providers = [];\n\nvar request = require(\"request\");\n\n//==============\n\n//expose list and item methods - pass straight to search type\n[\"list\", \"item\"].forEach(function(fnName) {\n\tsearch[fnName] = function(data, callback) {\n\n\t\tvar p = providers[data.provider];\n\t\tif(!p)\n\t\t\treturn callback(\"Missing provider: \" + data.provider);\n\n\t\tvar type = types[p.type];\n\t\tif(!type)\n\t\t\treturn callback(\"Invalid type\");\n\n\t\ttype[fnName](p, data, callback);\n\t};\n});\n\n//==============\n\nsearch.setproviders = function(data, callback) {\n\tif(!data.url)\n\t\treturn callback(\"Missing url\");\n\trequest.get(data.url, function(err, httpResponse, body) {\n\t\tif(err)\n\t\t\treturn callback(\"Failed to load: \" + data.url);\n\t\ttry {\n\t\t\tvar newProviders = JSON.parse(body);\n\t\t\t//expose only the \"names\" to the frontend\n\t\t\tvar names = {};\n\t\t\tfor(var id in newProviders) {\n\t\t\t\tvar p = newProviders[id];\n\t\t\t\tnames[id] = p.name;\n\t\t\t}\n\t\t\tproviders = newProviders;\n\t\t\tsearch.providers = names;\n\t\t\tsearch.emit(\"update\");\n\t\t\tconsole.log(\"loaded search providers: %s\", Object.keys(names).join(\", \"));\n\t\t\tcallback(null, names);\n\t\t} catch(err) {\n\t\t\treturn callback(\"Invalid JSON\");\n\t\t}\n\t});\n};\n\nvar url = process.env.SEARCH_PROVIDERS_URL;\nif(url) search.setproviders({url:url}, function(err, p) {\n\tif(err) console.error(\"Failed to load search providers from: %s (%s)\", url, err);\t\n});\n\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/searchers/screen-scraper.js":"\nvar request = require(\"request\");\nvar cheerio = require(\"cheerio\");\nvar $ = cheerio.load(\"\");\n\nvar template = function(str, data) {\n\treturn str.replace(/\\{\\s*(\\w+)\\s*\\}/g, function(all, key) {\n\t\treturn encodeURIComponent(data[key]);\n\t});\n};\n\nvar load = function(url, callback) {\n\trequest({\n\t\tmethod: \"GET\",\n\t\turl: url,\n\t\tgzip: true,\n\t\theaders: {\n\t\t\t//just a regular browser, nothing to see here...\n\t\t\t\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 \" + \n\t\t\t\t\"(KHTML, like Gecko) Chrome/40.0.2214.91 Safari/537.36\"\n\t\t}\n\t}, function(err, httpResponse, body) {\n\t\t// require(\"fs\").writeFileSync(\"./prototype/results.html\", body);\n\t\tif(err)\n\t\t\treturn callback(\"Failed to load: '\" + url + \"': \" + err);\n\t\tvar root = cheerio.load(body);\n\t\troot.find = root;\n\t\tcallback(null, root);\n\t});\n};\n\nvar val = function(elem, selector) {\n\n\tif(!elem.find)\n\t\telem = $(elem);\n\n\t//regex selector?\n\tif(/^\\/(.+)\\/$/.test(selector)) {\n\t\tvar re = new RegExp(RegExp.$1);\n\t\t//test against html\n\t\tif(re.test(elem.html()))\n\t\t\treturn RegExp.$1.replace(\"&nbsp;\", \" \").replace(\"&#xA0;\", \" \");\n\t\treturn \"\";\n\t}\n\n\t//attribute selector?\n\tvar attr;\n\tselector = selector.replace(/^(.+)@(\\w+)$/, function(all, sel, a) {\n\t\tattr = a;\n\t\treturn sel;\n\t});\n\n\tvar e = elem.find(selector);\n\t// console.log(\"selector '%s' [attr: %s] [results: %s]\",  selector, attr, e ? e.length: null);\n\tif(!e || e.length === 0)\n\t\treturn null;\n\treturn attr ? e.attr(attr) : e.text();\n};\n\n//==========\n\nexports.list = function(p, data, callback) {\n\tif(!data || !data.query)\n\t\treturn callback(\"Missing query\");\n\n\tvar page = data.page || 1;\n\n\tvar url = template(p.list.url, {\n\t\tpage: page,\n\t\tzpage: page-1,//zero-indexed page\n\t\tquery: data.query\n\t});\n\n\tvar origin = /(https?:\\/\\/[^\\/]+)/.test(url) && RegExp.$1;\n\tif(!origin)\n\t\treturn callback(\"Invalid URL\");\n\n\tload(url, function (err, root) {\n\t\tif(err)\n\t\t\treturn callback(\"Search provider could not reached\");\n\n\t\tvar items = root.find(p.list.items);\n\n\t\t// console.log(\"loaded %s, selector '%s' yeilds %s results\",  url, p.list.items, items.length);\n\n\t\tvar results = [];\n\t\tfor(var i = 0; i < items.length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tvar missing = false;\n\t\t\tvar result = {};\n\t\t\tfor(var k in p.list.item) {\n\t\t\t\tvar v = val(item, p.list.item[k]);\n\t\t\t\t//exclude items with missing values\n\t\t\t\tif(!v) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//url convert rela->abs\n\t\t\t\tif(k === \"url\" && v && v[0] === \"/\")\n\t\t\t\t\tv = origin + v;\n\t\t\t\t//insert\n\t\t\t\tresult[k] = v;\n\t\t\t}\n\n\t\t\tif(!missing)\n\t\t\t\tresults.push(result);\n\t\t}\n\n\t\tcallback(null, results);\n\t});\n};\n\nexports.item = function(p, data, callback) {\n\n\tif(!p.item)\n\t\treturn callback(\"Provider cannot retrieve items\");\n\tif(!data.url)\n\t\treturn callback(\"Missing url\");\n\n\tload(data.url, function(err, root) {\n\t\tif(err)\n\t\t\treturn callback(\"Failed to load: \" + data.url);\n\n\t\tvar result = {};\n\t\tfor(var k in p.item) {\n\t\t\tvar v = val(root, p.item[k]);\n\t\t\tif(v) result[k] = v;\n\t\t}\n\n\t\t// console.log(data.url, result);\n\t\tcallback(null, result);\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/searchers/json-api.js":"\nexports.list = function(p, data, callback) {\n\tcallback(\"Not implemented\");\n};\n\nexports.item = function(p, data, callback) {\n\tcallback(\"Not implemented\");\n};\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/torrents.js":"\nvar events = require('events');\nvar torrents = module.exports = new events.EventEmitter();\n\nvar async = require('async');\nvar parse = require('parse-torrent');\nvar Archive = require('zip-stream');\nvar request = require('request');\nvar torrentStream = require('torrent-stream');\n\nvar File = require(\"./file\");\nvar backend = require('./backend');\n\ntorrents.filesDownloading = 0;\nvar list = torrents.list = [];\n\n//=============\n// every second, check the status of all active torrents\n\nsetInterval(function() {\n\tvar changed = false;\n\n\tvar filesDownloading = 0;\n\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar t = list[i];\n\n\t\tif(!t.$engine)\n\t\t\tcontinue;\n\n\t\t//check torrent speed\n\t\tvar swarm = t.$engine.swarm;\n\n\t\tvar status = {\n\t\t\tdown: swarm.downloaded,\n\t\t\tdownps: swarm.downloadSpeed(),\n\t\t\tup: swarm.uploaded,\n\t\t\tupps: swarm.uploadSpeed()\n\t\t};\n\n\t\tfor(var k in status)\n\t\t\tif(status[k] !== t.status[k])\n\t\t\t\tchanged = true;\n\n\t\tif(t.zipping)\n\t\t\tfilesDownloading++;\n\n\t\t//check file status\n\t\tt.files.forEach(function(f) {\n\t\t\tif(f.uploading)\n\t\t\t\tfilesDownloading++;\n\t\t});\n\t\tt.status = status;\n\t}\n\n\tif(torrents.filesDownloading !== filesDownloading) {\n\t\ttorrents.filesDownloading = filesDownloading;\n\t\tchanged = true;\n\t}\n\n\tif(changed)\n\t\ttorrents.emit(\"update\");\n}, 1000);\n\n//=============\n\n\nvar fs = require(\"fs\");\nvar rm = require(\"rimraf\");\nvar path = require(\"path\");\nvar TMP_DIR = path.resolve(\"./tmp\");\nvar TS_DIR = path.join(TMP_DIR, \"torrent-stream\");\n\n//on start, reopen existing torrents\nsetTimeout(function() {\n\tif(!fs.existsSync(TS_DIR))\n\t\treturn;\n\tvar files = fs.readdirSync(TS_DIR);\n\tif(!files)\n\t\treturn;\n\tfiles.filter(function(f) {\n\t\treturn /\\.torrent$/.test(f);\n\t}).forEach( function(f) {\n\t\tvar buff = fs.readFileSync(path.join(TS_DIR, f));\n\t\tload(parse(buff), function(err) {\n\t\t\tif(!err)\n\t\t\t\tconsole.log(\"Restored torrent\", f);\n\t\t});\n\t});\n});\n\n\n//=============\n//helpers\n\nvar findTorrent = function(hash) {\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar t = list[i];\n\t\tif(t.hash === hash)\n\t\t\treturn t;\n\t}\n\treturn null;\n};\n\nvar findFile = function(torrent, path) {\n\tfor(var i = 0; i < torrent.files.length; i++) {\n\t\tvar f = torrent.files[i];\n\t\tif(f.path === path)\n\t\t\treturn f;\n\t}\n\treturn null;\n};\n\n//=============\n\nvar load = function(t, callback) {\n\tif(!t)\n\t\treturn callback(\"Invalid torrent\");\n\tif(!t.infoHash)\n\t\treturn callback(\"Missing hash\");\n\n\tvar torrent = findTorrent(t.infoHash);\n\tif(torrent)\n\t\treturn callback(\"Torrent already exists\");\n\n\ttorrent = {\n\t\t$engine: null,\n\t\thash: t.infoHash,\n\t\tname: t.name,\n\t\ttrackers: t.announce,\n\t\tmagnet: parse.toMagnetURI(t),\n\t\tfiles: [],\n\t\tstatus: {}\n\t};\n\tlist.push(torrent);\n\ttorrents.emit(\"update\");\n\n\t//loaded, now open it\n\ttorrents.open({ hash:torrent.hash }, callback);\n};\n\ntorrents.load = function(data, callback) {\n\tif(data.magnet) {\n\t\tload(parse(data.magnet), callback);\n\t} else if(data.torrent) {\n\t\trequest({\n\t\t\tmethod: \"GET\",\n\t\t\turl: data.torrent,\n\t\t\tgzip: true,\n\t\t\tencoding: null //buffer!\n\t\t}, function(err, resp, body) {\n\t\t\tif(err)\n\t\t\t\treturn callback(\"Invalid URL\");\n\t\t\tvar t;\n\t\t\ttry {\n\t\t\t\tt =  parse(body) ;\n\t\t\t} catch(e) {\n\t\t\t\treturn callback(\"Failed to parse torrent\");\n\t\t\t}\n\t\t\tload(t, callback);\t\t\t\n\t\t});\n\t} else {\n\t\treturn callback(\"Invalid request\");\n\t}\n};\n\ntorrents.open = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Torrent missing\");\n\tif(torrent.$engine)\n\t\treturn callback(\"Torrent already open\");\n\n\t//dont wait - open torrent stream, mark openning and callback\n\tvar engine = torrentStream(torrent.magnet, {\n\t\tconnections: 100,\n\t\tuploads: 0, //TODO should upload, though we can be highly CPU/mem bound\n\t\ttmp: TMP_DIR,\n\t\tverify: true,\n\t\tdht: true\n\t});\n\n\ttorrent.$engine = engine;\n\ttorrent.openning = true;\n\ttorrents.emit(\"update\");\n\tcallback(null);\n\n\tengine.on('error', function(err) {\n\t\t//TODO destroy torrent\n\t\tconsole.error(\"torrent '%s' error: %s\", torrent.name, err);\n\t});\n\n\tengine.on('ready', function() {\n\t\t//overwrite magnet name with real name\n\t\ttorrent.name = engine.torrent.name;\n\t\ttorrent.files = engine.files.map(function(f, i) {\n\t\t\treturn new File(f, i, torrent);\n\t\t});\n\t\ttorrent.openning = false;\n\t\ttorrent.open = true;\n\t\ttorrents.emit(\"update\");\n\t});\n};\n\ntorrents.close = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Torrent missing\");\n\tif(!torrent.$engine)\n\t\treturn callback(\"Torrent not open\");\n\n\ttorrent.$engine.destroy(function() {\n\n\t\t//ensure all files are stopped\n\t\tif(torrent.files) {\n\t\t\ttorrent.files.forEach(function(f) {\n\t\t\t\tf.cancel();\n\t\t\t});\n\t\t}\n\n\t\ttorrent.files = null;\n\t\ttorrent.open = false;\n\t\ttorrent.$engine = null;\n\t\ttorrents.emit(\"update\");\n\t\tcallback(null);\n\t});\n};\n\ntorrents.remove = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Torrent missing\");\n\tif(torrent.$engine)\n\t\treturn callback(\"Torrent is still open\");\n\tvar i = list.indexOf(torrent);\n\tlist.splice(i, 1);\n\ttorrents.emit(\"update\");\n\n\t//clear torrent files and torrent\n\trm(path.join(TS_DIR, torrent.hash), function(err) {\n\t\tif(err) console.log(\"failed to delete: %s\", torrent.hash);\n\t});\n\trm(path.join(TS_DIR, torrent.hash+\".torrent\"), function(err) {\n\t\tif(err) console.log(\"failed to delete: %s.torrent\", torrent.hash);\n\t});\n\n\tcallback(null);\n};\n\ntorrents.downloadFile = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Missing torrent\");\n\tvar file = findFile(torrent, data.path);\n\tif(!file)\n\t\treturn callback(\"Missing file\");\n\tif(file.downloading)\n\t\treturn callback(\"Already downloading\");\n\n\t//callback to user early since uploads can take hours...\n\t//user receives updates via websockets\n\tcallback(null);\n\tfile.uploading = true;\n\ttorrents.emit(\"update\");\n\n\t//pass copy of file to backend\n\tbackend.upload({\n\t\tpath: file.path,\n\t\tlength: file.length,\n\t\tcreateReadStream: file.createReadStream.bind(file)\n\t}, function(err) {\n\t\tfile.uploading = false;\n\t\t//receive result from backend\n\t\tif(err && err !== \"cancelled\") {\n\t\t\tfile.downloadError = \"Backend Error\";\n\t\t\ttorrents.emit(\"update\");\n\t\t\treturn console.error(\"backend error: \", err);\n\t\t}\n\t\ttorrents.emit(\"update\");\n\n\t\t//success, now re-list\n\t\tbackend.list(function(err, files) {\n\t\t\tif(err) return console.error(\"failed to list\");\n\t\t\ttorrents.emit(\"update\", files);\n\t\t});\n\t});\n};\n\ntorrents.cancelFile = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Missing torrent\");\n\tvar file = findFile(torrent, data.path);\n\tif(!file)\n\t\treturn callback(\"Missing file\");\n\tif(!file.downloading)\n\t\treturn callback(\"Not downloading\");\n\n\tvar success = file.cancel();\n\tcallback(success ? null : \"Failed to close file\");\n};\n\n\ntorrents.zipAll = function(data, callback) {\n\tvar torrent = findTorrent(data.hash);\n\tif(!torrent)\n\t\treturn callback(\"Missing torrent\");\n\n\tvar files = torrent.files;\n\n\tvar archive = new Archive();\n\n\tarchive.on('error', function(err) {\n\t\tconsole.error(\"zip error:\", err);\n\t});\n\n\tasync.series(files.map(function(f, i) {\n\t\treturn function(cb) {\n\t\t\tarchive.entry(f.createReadStream(), { name: f.path }, function(err) {\n\t\t\t\tif(err)\n\t\t\t\t\treturn cb(err);\n\t\t\t\tcb(null);\n\t\t\t});\n\t\t};\n\t}), function(err) {\n\t\tif(err) {\n\t\t\ttorrent.zipping = false;\n\t\t\ttorrents.emit(\"update\");\n\t\t\treturn console.error(\"zip archive error:\", err);\n\t\t}\n\t\tarchive.finish();\n\t});\n\n\ttorrent.zipping = true;\n\ttorrents.emit(\"update\");\n\n\t//callback to user early since uploads can take hours...\n\t//user receives updates via websockets\n\tcallback(null);\n\n\t//pass zip stream to backend\n\tbackend.upload({\n\t\tpath: torrent.name + \".zip\",\n\t\tlength: files.reduce(function(len, f) { return len+f.length; }, 0),\n\t\tcreateReadStream: function() { return archive; }\n\t}, function(err) {\n\t\ttorrent.zipping = false;\n\t\ttorrents.emit(\"update\");\n\t\tif(err) {\n\t\t\treturn console.error(\"zip upload error:\", err);\n\t\t}\n\t\tbackend.list(function(err, files) {\n\t\t\tif(err) return console.error(\"failed to list\");\n\t\t\ttorrents.emit(\"update\", files);\n\t\t});\n\t});\n};\n\ntorrents.trash = function(data, callback) {\n\n\tif(!data.path)\n\t\treturn callback(\"Missing path\");\n\n\tbackend.remove(data.path, function(err) {\n\t\tif(err) return callback(\"Failed to trash: \" + err);\n\n\t\tbackend.list(function(err, files) {\n\t\t\tif(err) return callback(\"Failed to list: \" + err);\n\t\t\ttorrents.emit(\"update\", files);\n\t\t\tcallback(null);\n\t\t});\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/bin.js":"#!/usr/bin/env node\nrequire(\"./server.js\");","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/backend.js":"//backend is a generic backend\n//when 'required' it chooses from a list of defined\n//backends based on present environment variables\n\nvar config = require(\"../config.json\");\nvar fs = require('fs');\n//list all backends\nvar backends = fs.readdirSync(__dirname+\"/backends\").filter(function(js) {\n\treturn js !== \"_template.js\" && (/\\.js$/).test(js);\n});\n\n//exit helper\nfunction exit(msg) {\n\tconsole.log(msg);\n\tprocess.exit(1);\n}\n\nvar matched = false;\n\n//load the *first* viable backend\nbackends.forEach(function(name) {\n\n\tif(matched)\n\t\treturn;//break\n\n\tvar backend = require(\"./backends/\"+name);\n\t\n\tvar vars = backend.vars;\n\n\tif(!backend.init)\n\t\texit(\"Backend \" + name + \" missing 'vars' array\");\n\n\tvar vals = vars.map(function(v) {\n\t\tvar val = process.env[v];\n\t\tif(!val)\n\t\t\tbackend = null;\n\t\treturn val;\n\t});\n\n\tif(!backend)\n\t\treturn;//continue\n\n\t//backend has been chosen by env vars,\n\t//now check its validity\n\n\tbackend.name = name;\n\n\tif(!backend.init)\n\t\texit(\"Backend \" + name + \" missing 'init(env vars...)' function\");\n\n\tbackend.init(config);\n\n\tif(typeof backend.upload !== \"function\")\n\t\texit(\"Backend \" + name + \" missing 'upload(torrent file, callback)' function\");\n\n\tif(typeof backend.remove !== \"function\")\n\t\texit(\"Backend \" + name + \" missing 'remove(path, callback)' function\");\n\n\tif(typeof backend.list !== \"function\")\n\t\texit(\"Backend \" + name + \" missing 'list(callback)' function\");\n\n\t//backend ready!\n\tmodule.exports = backend;\n\tmatched = true;\n});\n\nif(!matched)\n\texit(\"No backend match. \"+\n\t\t\"Environment variables missing for: \" + \n\t\tbackends.join(\", \"));\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/backends/aws.js":"\nvar through = require('../util/through');\nvar mime = require('mime');\nvar async = require('async');\nvar AWS = require(\"aws-sdk\");\n\nvar s3;\nvar bucket;\nvar region;\n\nvar CONCURRENT_FILES = 1;\nvar CONCURRENT_UPLOADS = 2;\nvar MIN_MULTIPART = 5*1024*1024;//~5Mb\n\nexports.vars = [\"AWS_BUCKET\", \"AWS_REGION\", \"AWS_ACCESS_KEY\", \"AWS_SECRET_KEY\"];\n\n//=============\n\nvar createMultipart = function(file, callback) {\n\ts3.createMultipartUpload({\n\t\tBucket: bucket,\n\t\tKey: file.path,\n\t\tContentType: mime.lookup(file.path),\n\t\tACL: \"public-read\"\n\t}, function (err, data) {\n\t\tif (err)\n\t\t\treturn callback(\"Failed to create multipart upload\");\n\t\tif (!data.UploadId)\n\t\t\treturn callback(\"Missing multipart upload ID\");\n\n\t\t//set upload info ($ == dont JSONify)\n\t\tfile.uploadId = data.UploadId;\n\t\tfile.etags = [];\n\n\t\t//multipart created, upload parts\n\t\tcallback(null, file);\n\t});\n};\n\n//upload worker function\nvar uploadPart = function(file, u, callback) {\n\n\t//cancelled\n\tif(!file.uploadId)\n\t\treturn callback(null);\n\n\ts3.uploadPart({\n\t\tBucket: bucket,\n\t\tKey: file.path,\n\t\tPartNumber: u.part+1,\n\t\tUploadId: file.uploadId,\n\t\tBody: u.buff\n\t}, function(err, data) {\n\t\tif(err)\n\t\t\treturn callback(err);\n\t\tfile.etags[u.part] = data.ETag;\n\t\tcallback(null);\n\t});\n};\n\nvar uploadParts = function(file, callback) {\n\n\t//this file's uploads queue\n\tvar uploads = async.queue(uploadPart.bind(null, file), CONCURRENT_UPLOADS);\n\n\tvar stream = file.createReadStream();\n\n\t//upload errored/cancelled!\n\tstream.on(\"error\", function(err) {\n\t\t//attempt abort\n\t\ts3.abortMultipartUpload({\n\t\t\tBucket: bucket,\n\t\t\tKey: file.path,\n\t\t\tUploadId: file.uploadId\n\t\t}, function(err) {\n\t\t\tif(err) console.error(\"failed to abort multipart\", err);\n\t\t});\n\n\t\t//signal closed\n\t\tfile.uploadId = null;\n\t\tuploads.kill();\n\t\t//upload cancelled!\n\t\tcallback(err);\n\t});\n\n\tvar buff = new Buffer(0);\n\tvar part = 0;\n\n\tstream.pipe(through(function transform(data, next) {\n\t\tbuff = Buffer.concat([buff, data]);\n\t\t//to prevent backlog, only ask for the 'next'\n\t\t//data when we're not uploading\n\t\tif(buff.length >= MIN_MULTIPART) {\n\t\t\tvar b = buff.slice(0, MIN_MULTIPART);\n\t\t\tbuff = buff.slice(MIN_MULTIPART);\n\t\t\tuploads.push({buff:b, part:part++}, next);\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t}, function end(done) {\n\t\tdone();\n\t\t//last part?\n\t\tif(buff.length > 0)\n\t\t\tuploads.push({buff:buff, part:part++});\n\t\t//download complete, prepare callback on upload complete\n\t\tuploads.drain = function() {\n\t\t\tcallback(null, file);\n\t\t};\n\t}));\n};\n\nvar completeMultipart = function(file, callback) {\n\ts3.completeMultipartUpload({\n\t\tBucket: bucket,\n\t\tKey: file.path,\n\t\tUploadId: file.uploadId,\n\t\tMultipartUpload: {\n\t\t\tParts: file.etags.map(function(e, i) {\n\t\t\t\treturn { ETag: e, PartNumber: i+1 };\n\t\t\t})\n\t\t}\n\t}, callback);\n};\n\n//=============\n\nvar uploadSinglePartFile = function(file, callback) {\n\tvar stream = file.createReadStream();\n\tvar cancelled = false;\n\n\tstream.on(\"error\", function(err) {\n\t\tcancelled = true;\n\t\tcallback(err);\n\t});\n\n\tvar buff = new Buffer(0);\n\tstream.pipe(through(function transform(b) {\n\t\tbuff = Buffer.concat([buff, b]);\n\t}, function end(done) {\n\t\tif(cancelled)\n\t\t\treturn;\n\t\ts3.putObject({\n\t\t\tBucket: bucket,\n\t\t\tKey: file.path,\n\t\t\tBody: buff,\n\t\t\tContentType: mime.lookup(file.path),\n\t\t\tContentLength: buff.length,\n\t\t\tACL: 'public-read'\n\t\t}, callback);\n\t}));\n};\n\n//=============\n\nvar upload = function(file, callback) {\n\tif(file.length <= 0)\n\t\treturn callback(\"Invalid length\");\n\t\n\tif(file.length < MIN_MULTIPART)\n\t\t//singlepart upload\n\t\tuploadSinglePartFile(file, callback);\n\telse\n\t\t//multipart upload - begin multipart flow\n\t\tasync.waterfall([\n\t\t\tcreateMultipart.bind(null, file),\n\t\t\tuploadParts,\n\t\t\tcompleteMultipart\n\t\t], callback);\n};\n\nvar queue = async.queue(upload, CONCURRENT_FILES);\n\n//=============\n\nexports.upload = function(file, callback) {\n\tqueue.push(file, callback);\n};\n\n//=============\n\nexports.list = function(callback) {\n\ts3.listObjects({Bucket:bucket}, function(err, data) {\n\t\tif (err)\n\t\t\treturn callback(err);\n\t\tvar files = {};\n\t\tdata.Contents.forEach(function(o){\n\t\t\tfiles[o.Key] = {\n\t\t\t\tlength: o.Size,\n\t\t\t\turl: 'https://s3-'+region+'.amazonaws.com/'+bucket+'/' + o.Key\n\t\t\t};\n\t\t});\n\t\tcallback(null, files);\n\t});\n};\n\n//=============\n\nexports.remove = function(path, callback) {\n\ts3.deleteObject({ Bucket:bucket, Key: path }, callback);\n};\n\n//=============\n\nexports.init = function(config) {\n\tbucket = config.AWS_BUCKET;\n\tregion = config.AWS_REGION;\n\n\t//init s3\n\ts3 = new AWS.S3({\n\t\taccessKeyId: config.AWS_ACCESS_KEY,\n\t\tsecretAccessKey: config.AWS_SECRET_KEY,\n\t\tregion: config.AWS_REGION\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/util/through.js":"var stream = require('stream');\nvar Transform = stream.Transform;\n \nmodule.exports = function through(opts, transform, flush) {\n \n\t//use default options\n\tif (typeof opts !== 'object') {\n\t\tflush = transform;\n\t\ttransform = opts;\n\t\topts = {\n\t\t\tobjectMode: true\n\t\t};\n\t}\n \n\t//always allow objects\n\tvar t = new Transform(opts);\n \n\t//depending on transform fn arity, pass in diff args\n\tt._transform =\n\t\ttypeof transform !== 'function' ? function throughzero(data, enc, next) {\n\t\t\tnext(null, data);\n\t\t} :\n\t\ttransform.length === 3 ? transform :\n\t\ttransform.length === 2 ? function throughtwo(obj, enc, next) {\n\t\t\ttransform.call(this, obj, next);\n\t\t} :\n\t\ttransform.length === 1 ? function throughone(obj, enc, next) {\n\t\t\ttransform.call(this, obj);\n\t\t\tnext();\n\t\t} :\n\t\tnull;\n \n\t//give stream objects names\n\tif (transform && transform.name)\n\t\tt.name = transform.name;\n \n\tt._flush = flush;\n\treturn t;\n};","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/backends/mega.js":"var async = require(\"async\");\nvar mega = require(\"mega\");\n\n\n//this backend will be used if *all* of these env 'vars' are present\nexports.vars = [\"MEGA_EMAIL\", \"MEGA_PASS\"];\n\nvar storage = null;\n\n//if these 'vars' are present, 'init' will be called on module load\nexports.init = function(config) {\n  storage = mega({\n    email: config.MEGA_EMAIL,\n    password: config.MEGA_PASS\n  }, function(err) {\n    if(err) {\n      console.log(\"Mega login failed: %s\", err);\n      process.exit(1);\n    }\n    console.log(\"Mega login success\");\n  });\n};\n\n//upload will be called to upload a downloading torrent file\nexports.upload = function(torrentFile, callback) {\n  if(!storage.root)\n    callback(\"Not ready\");\n\n  var dirs = torrentFile.path.split(\"/\");\n  var name = dirs.pop();\n  var dir = null;\n  var root = storage.root;\n\n  //call back when all dirs made\n  mkdirp(dirs, root, function(err, dir) {\n    if(err)\n      return callback(err);\n    upload(dir);\n  });\n\n  //before we can upload, we need to mkdirp\n  function mkdirp(dirs, parent, cb) {\n    var d = dirs.shift();\n    storage.mkdir({\n      name: d,\n      target: parent\n    }, function(err, dir) {\n      if(err)\n        return cb(err);\n      if(dirs.length > 0) //dont callback yet!\n        mkdirp(dirs, dir, cb);\n      else\n        cb(null, dir);\n    });\n  }\n\n  function upload(dir) {\n    var upload = storage.upload({\n      name: name,\n      size: torrentFile.length,\n      target: dir\n    });\n\n    var stream = torrentFile.createReadStream();\n\n    stream.pipe(upload);\n\n    upload.on(\"error\", function(err) {\n      callback(err);\n    });\n\n    //callback when stream has been fully uploaded\n    upload.on(\"complete\", function(f) {\n      console.log(\"uploaded\", f.name);\n      callback(null);\n    });\n  }\n};\n\n//list will be called to list all stored files\nexports.list = function(callback) {\n\n  storage.reload(function(err) {\n    if(err)\n      return callback(\"Mega list-dir failed: \" + err);\n\n    var fetches = [];\n    var files = {};\n\n    eachFile(function(f) {\n      if(f.directory)\n        return;\n      var path = getPath(f);\n      var tcldFile = { length: f.size, url: null };\n      fetches.push(function fetchUrl(cb) {\n        f.link(function(err, url) {\n          if(err) return cb(err);\n          tcldFile.url = url;\n          cb(null);\n        });\n      });\n      //url is null until it is fetched\n      files[path] = tcldFile;\n    });\n\n    //fetch all links, 6 at a time\n    async.parallelLimit(fetches, 6, function(err) {\n      if(err)\n        return callback(\"Mega fetch-url failed: \" + err);\n      // console.log(\"list success\", files);\n      callback(null, files);\n    });\n  });\n};\n\n//removes a file at the given path (torrentFile.path)\nexports.remove = function(path, callback) {\n\n  var parts = path.split(\"/\");\n  var file = null;\n  var dir = storage.root;\n\n  while(parts.length) {\n    var p = parts.shift();\n    if(!dir.directory)\n      return callback(\"Missing\");\n\n    var f = null;\n    for(var i = 0; i < dir.children.length; i++) {\n      var c = dir.children[i];\n      if(c.name === p) {\n        f = c;\n        break;\n      }\n    }\n\n    if(!f)\n      return callback(\"Missing\");\n    dir = file = f;\n  }\n\n  f.delete(function(err) {\n    if(err)\n      return callback(err);\n    console.log(\"deleted\", path);\n    setTimeout(callback, 5000);\n  });\n};\n\n\n//========\n\nfunction eachFile(fn) {\n  Object.keys(storage.files).forEach(function(id) {\n    var f = storage.files[id];\n    fn(f);\n  });\n}\n\n// function getRoot() {\n// }\n\nfunction getPath(f) {\n  var path = \"\";\n  while(f) {\n    var name = f.name;\n    if(name === \"Cloud Drive\")\n      break;\n    if(f.directory)\n      name += \"/\";\n    path = name + path;\n    f = f.parent;\n  }\n  return path;\n}","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/file.js":"var torrents = require(\"./torrents\");\nvar stream = require(\"stream\");\nvar through = require('./util/through');\n\n//in effect, this controls the size of the download buffer,\n//it gets cleared as the upload progresses (prevents buffering the entire download in memory)\nvar MIN_PIECE_SIZE = 50*1024*1024;//~50Mb\n\nfunction File(f, index, torrent) {\n\tvar file = this;\n\tfile.$f = f;\n\t//TODO (@jpillora) make downloads actually fall at piece boundaries\n\tvar pieceSize = torrent.$engine.torrent.pieceLength;\n\tfile.$pieceSize = Math.ceil(MIN_PIECE_SIZE/pieceSize)*pieceSize;\n\t\n\tfile.i = index;\n\tfile.downloading = false;\n\tfile.name = f.name;\n\tfile.path = f.path;\n\tfile.length = f.length;\n};\n\nFile.prototype = {\n\tcreateReadStream: function() {\n\t\tvar file = this;\n\n\t\t//already created\n\t\tif(file.$r)\n\t\t\treturn file.$r;\n\n\t\t//start download\n\t\tfile.downloadError = undefined;\n\t\tfile.cancelled = undefined;\n\t\tfile.downloading = true;\n\t\tfile.downloadLength = 0;\n\t\ttorrents.emit(\"update\");\n\n\t\tvar piece = 0;\n\t\tvar piecing = false;\n\t\tvar waiting = false;\n\t\tvar r = file.$r = new stream.Readable();\n\n\t\tvar read = r._read = function() {\n\n\t\t\t//completed early\n\t\t\tif(file.cancelled)\n\t\t\t\treturn;\n\n\t\t\t//download one piece at a time\n\t\t\tif(piecing) {\n\t\t\t\twaiting = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpiecing = true;\n\t\t\twaiting = false;\n\n\t\t\tvar s = piece * file.$pieceSize;\n\t\t\tvar e = Math.min(s + file.$pieceSize, file.length);\n\n\t\t\t//EOF completed successfully\n\t\t\tif(s >= file.length)\n\t\t\t\treturn file.$complete();\n\n\t\t\t//pull the next piece\n\t\t\tvar download = file.$d = file.$f.createReadStream({\n\t\t\t\tstart: s,\n\t\t\t\tend: e - 1\n\t\t\t});\n\n\t\t\t//extract chunk, place in this file\n\t\t\tvar monitor = through(function transform(b) {\n\t\t\t\tfile.downloadLength += b.length;\n\t\t\t\ttorrents.emit(\"update\");\n\t\t\t\tr.push(b);\n\t\t\t}, function(flush) {\n\t\t\t\t//next piece\n\t\t\t\tpiece++;\n\t\t\t\tpiecing = false;\n\t\t\t\tif(waiting)\n\t\t\t\t\tread();\n\t\t\t\tflush();\n\t\t\t});\n\n\t\t\tdownload.pipe(monitor);\n\t\t};\n\n\t\treturn r;\n\t},\n\tcancel: function() {\n\t\tvar file = this;\n\t\t//not open\n\t\tif(!file.$r || file.cancelled)\n\t\t\treturn null;\n\n\t\t//attempt to close current download\n\t\tif(file.$d)\n\t\t\tfile.$d.destroy();\n\n\t\t//close!\n\t\tfile.cancelled = true;\n\t\tfile.$complete(\"cancelled\");\n\t\tfile.$r = null;\n\t\treturn true;\n\t},\n\t$complete: function(err) {\n\t\tvar file = this;\n\t\tif(!file.downloading)\n\t\t\treturn;\n\t\tfile.downloading = false;\n\t\ttorrents.emit(\"update\");\n\t\tif(!file.$r)\n\t\t\treturn;\n\n\t\tif(err)\n\t\t\tfile.$r.emit(\"error\", err);\n\t\telse\n\t\t\tfile.$r.push(null);//EOF\n\t}\n};\n\nmodule.exports = File;","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/ws.js":"\nvar WebSocket = require('ws');\n\nvar json = \"\";\nvar data = null;\nvar conns = [];\nvar THROTTLE = 100;\nvar queued = false;\n\n//send keepalive pings\nsetInterval(function() {\n\tconns.forEach(function(conn) {\n\t\tconn.ssend(\"ping\");\n\t});\n}, 30*1000);\n\nexports.install = function(server) {\n\n\tvar ws = new WebSocket.Server({ server: server });\n\n\t//this is required to allow the error to fall\n\t//through to the http server\n\tws.on(\"error\", function() {});\n\n\tws.on('connection', function connection(conn) {\n\t\t//safe send\n\t\tconn.ssend = function(str){ \n\t\t\tif(this.readyState === WebSocket.OPEN)\n\t\t\t\tthis.send(str);\n\t\t};\n\t\t//track all connections\n\t\tconns.push(conn);\n\t\tconn.on('close', function() {\n\t\t\tvar i = conns.indexOf(conn);\n\t\t\tif(i >= 0) conns.splice(i, 1);\n\t\t});\n\n\t\t//noop (dont buffer data)\n\t\tconn.on('data', function() {\n\t\t});\n\n\t\t//initially sends the last broadcast\n\t\tif(json) conn.ssend(json);\n\t});\n};\n\nfunction broadcast() {\n\tqueued = false;\n\t//don't include $properties\n\tjson = JSON.stringify(data, function(k,v){\n\t\treturn typeof k === \"string\" && k[0] === \"$\" ? undefined : v;\n\t}, 2);\n\tconns.forEach(function(conn) {\n\t\tconn.ssend(json);\n\t});\n}\n\n//actually just throttles to the private 'broadcast' function\nexports.broadcast = function(d) {\n\tdata = d; //always use latest broadcast\n\tif(queued) return;\n\tqueued = true;\n\tsetTimeout(broadcast, THROTTLE);\n};","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/static/app.js":"var window = this;\n\n//special angular merge\nvar merge = function(x, y) {\n\tif (!x || typeof x !== \"object\" ||\n\t\t!y || typeof y !== \"object\")\n\t\treturn y;\n\tvar k;\n\tif (x instanceof Array && y instanceof Array)\n\t\twhile (x.length > y.length)\n\t\t\tx.pop();\n\telse\n\t\tfor (k in x)\n\t\t\tif (k[0] !== \"$\" && !(k in y))\n\t\t\t\tdelete x[k];\n\tfor (k in y)\n\t\tx[k] = merge(x[k], y[k]);\n\treturn x;\n};\n\nvar app = window.angular.module('app', []);\n\napp.filter('keys', function() {\n\treturn Object.keys;\n});\n\napp.filter('filename', function() {\n\treturn function(path) {\n\t\treturn (/\\/([^\\/]+)$/).test(path) ? RegExp.$1 : path;\n\t};\n});\n\napp.filter('bytes', function(bytes) {\n\treturn bytes;\n});\n\napp.factory('bytes', function() {\n\tvar scale = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];\n\treturn function(n) {\n\t\tvar i = 0;\n\t\tvar s = scale[i];\n\t\tif (typeof n !== 'number') {\n\t\t\treturn \"-\";\n\t\t}\n\t\twhile (n > 1000) {\n\t\t\ts = scale[++i] || 'x10^' + (i * 3);\n\t\t\tn = Math.round(n / 100) / 10;\n\t\t}\n\t\treturn \"\" + n + \" \" + s;\n\t};\n});\n\napp.directive('ngEnter', function() {\n\treturn function(scope, element, attrs) {\n\t\telement.bind(\"keydown keypress\", function(event) {\n\t\t\tif (event.which === 13) {\n\t\t\t\tscope.$apply(function() {\n\t\t\t\t\tscope.$eval(attrs.ngEnter);\n\t\t\t\t});\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t});\n\t};\n});\n\n//TODO remove this hack\napp.directive('jpSrc', function() {\n\treturn function(scope, element, attrs) {\n\t\tscope.$watch(attrs.jpSrc, function(src) {\n\t\t\telement.attr(\"src\", src);\n\t\t});\n\t};\n});\n\napp.factory('storage', function() {\n\treturn window.localStorage || {};\n});\n\napp.factory('request', function($rootScope, $http) {\n\n\tvar inflight = {};\n\n\tvar request = $rootScope.request = {};\n\trequest.ing = false;\n\trequest.count = 0;\n\trequest.to = function(prefix) {\n\t\tprefix = '{\"e\":\"' + prefix;\n\t\tfor (var k in inflight)\n\t\t\tif (k.indexOf(prefix) === 0)\n\t\t\t\treturn true;\n\t\treturn false;\n\t};\n\n\treturn function(endpoint, input, callback) {\n\t\t//prevent multiple clicks\n\t\tvar reqID = JSON.stringify({\n\t\t\te: endpoint,\n\t\t\ti: input\n\t\t});\n\t\tif (inflight[reqID])\n\t\t\treturn;\n\t\tinflight[reqID] = true;\n\t\trequest.count++;\n\t\trequest.ing = request.count > 0;\n\n\t\t$http.post(\"/api/\" + endpoint, input)\n\t\t\t.success(function(data) {\n\t\t\t\tconsole.log(\"POST OK\", endpoint);\n\t\t\t\t$rootScope.err = null;\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback(null, data);\n\t\t\t}).error(function(err) {\n\t\t\t\tconsole.error(\"POST ERROR\", err);\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback(err);\n\t\t\t\telse\n\t\t\t\t\t$rootScope.err = err;\n\t\t\t}).finally(function() {\n\t\t\t\tdelete inflight[reqID];\n\t\t\t\trequest.count--;\n\t\t\t\trequest.ing = request.count > 0;\n\t\t\t});\n\t};\n});\n\n\n\napp.controller(\"OmniController\", function($scope, $rootScope, storage) {\n\t$rootScope.omni = $scope;\n\t$scope.omni = storage.tcOmni || \"\";\n\n\t//edit fields\n\t$scope.edit = false;\n\t$scope.trackers = [{\n\t\tv: \"\"\n\t}];\n\n\t$scope.provider = storage.tcProvider || \"\";\n\n\t$scope.$watch(\"provider\", function(p) {\n\t\tstorage.tcProvider = p;\n\t\t$scope.parse();\n\t});\n\n\t//if unset, set to first provider\n\t$rootScope.$watch(\"data.providers\", function(providers) {\n\t\tif ($scope.provider) return;\n\t\tfor (var id in providers) break;\n\t\t$scope.provider = id;\n\t\t$scope.parse();\n\t});\n\n\tvar parseTorrent = function() {\n\t\t$scope.torrent = true;\n\t};\n\n\tvar parseMagnet = function(params) {\n\t\t$scope.magnet = true;\n\t\tvar m = window.queryString.parse(params);\n\n\t\tif (!/^urn:btih:([A-Za-z0-9]+)$/.test(m.xt)) {\n\t\t\t$scope.omnierr = \"Invalid Info Hash\";\n\t\t\treturn;\n\t\t}\n\n\t\t$scope.infohash = RegExp.$1;\n\t\t$scope.name = m.dn || \"\";\n\n\t\t//no trackers :O\n\t\tif (!m.tr)\n\t\t\treturn;\n\n\t\t//force array\n\t\tif (!(m.tr instanceof Array))\n\t\t\tm.tr = [m.tr];\n\n\t\t//in place map\n\t\tfor (var i = 0; i < m.tr.length; i++)\n\t\t\t$scope.trackers[i] = {\n\t\t\t\tv: m.tr[i]\n\t\t\t};\n\n\t\twhile ($scope.trackers.length > m.tr.length)\n\t\t\t$scope.trackers.pop();\n\n\t\t$scope.trackers.push({\n\t\t\tv: \"\"\n\t\t});\n\t};\n\n\tvar parseSearch = function() {\n\t\t$scope.search = true;\n\t\twhile ($scope.results.length)\n\t\t\t$scope.results.pop();\n\t};\n\n\t$scope.parse = function() {\n\t\tstorage.tcOmni = $scope.omni;\n\t\t$scope.omnierr = null;\n\t\t$scope.torrent = false;\n\t\t$scope.magnet = false;\n\t\t$scope.search = false;\n\t\t$scope.page = 1;\n\t\t$scope.hasMore = true;\n\t\t$scope.noResults = false;\n\t\t$scope.results = [];\n\n\t\tif (/^https?:\\/\\//.test($scope.omni))\n\t\t\tparseTorrent();\n\t\telse if (/^magnet:\\?(.+)$/.test($scope.omni))\n\t\t\tparseMagnet(RegExp.$1);\n\t\telse if ($scope.omni)\n\t\t\tparseSearch();\n\t\telse\n\t\t\t$scope.edit = false;\n\t};\n\t$scope.parse();\n\n\tvar magnetURI = function(name, infohash, trackers) {\n\t\treturn \"magnet:?\" +\n\t\t\t\"xt=urn:btih:\" + (infohash || '') + \"&\" +\n\t\t\t\"dn=\" + (name || '').replace(/\\W/g, '').replace(/\\s+/g, '+') +\n\t\t\t(trackers || []).map(function(t) {\n\t\t\t\treturn \"&tr=\" + encodeURIComponent(t.v);\n\t\t\t}).join('');\n\t};\n\n\t$scope.stringify = function() {\n\t\t$scope.omnierr = null;\n\n\t\tif (!/^[A-Za-z0-9]+$/.test($scope.infohash)) {\n\t\t\t$scope.omnierr = \"Invalid Info Hash\";\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < $scope.trackers.length;)\n\t\t\tif (!$scope.trackers[i].v)\n\t\t\t\t$scope.trackers.splice(i, 1);\n\t\t\telse\n\t\t\t\ti++;\n\n\t\t$scope.omni = magnetURI($scope.name, $scope.infohash, $scope.trackers);\n\n\t\t$scope.trackers.push({\n\t\t\tv: \"\"\n\t\t});\n\t};\n\n\t$scope.searchList = function() {\n\t\t$scope.searchAPI(\"list\", {\n\t\t\tprovider: $scope.provider,\n\t\t\tquery: $scope.omni,\n\t\t\tpage: $scope.page\n\t\t}, function(err, results) {\n\t\t\tif (err)\n\t\t\t\treturn $scope.omnierr = err;\n\t\t\tif (results.length === 0) {\n\t\t\t\t$scope.noResults = true;\n\t\t\t\t$scope.hasMore = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\t\t$scope.results.push(results[i]);\n\t\t\t}\n\t\t\t$scope.page++;\n\t\t});\n\t};\n\n\t$scope.searchLoad = function(result) {\n\n\t\t//if search item has magnet, download now!\n\t\tif (result.magnet) {\n\t\t\t$scope.torrentsAPI(\"load\", {\n\t\t\t\tmagnet: result.magnet\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t//else, look it up via url\n\t\tif (!result.url)\n\t\t\treturn $scope.omnierr = \"No URL found\";\n\n\t\t$scope.searchAPI(\"item\", {\n\t\t\tprovider: $scope.provider,\n\t\t\turl: result.url\n\t\t}, function(err, data) {\n\t\t\tif (err)\n\t\t\t\treturn $scope.omnierr = err;\n\n\t\t\tvar load = {};\n\n\t\t\tif (data.magnet) {\n\t\t\t\tload.magnet = data.magnet;\n\t\t\t} else if (data.infohash) {\n\t\t\t\tload.magnet = magnetURI(result.name, data.infohash, [{\n\t\t\t\t\tv: data.tracker\n\t\t\t\t}]);\n\t\t\t} else {\n\t\t\t\t$scope.omnierr = \"No magnet or infohash found\";\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$scope.torrentsAPI(\"load\", load);\n\t\t});\n\t};\n});\n\n//RootController\napp.run(function($rootScope, request) {\n\n\tvar $scope = window.scope = $rootScope;\n\t$scope.data = {};\n\n\t$scope.searchAPI = function(method, input, callback) {\n\t\trequest(\"search/\" + method, input, callback);\n\t};\n\n\t$scope.torrentsAPI = function(method, input) {\n\t\trequest(\"torrents/\" + method, input);\n\t};\n\n\t$scope.uploaded = function(f) {\n\t\tvar path = typeof f === \"object\" ? f.path : f;\n\t\treturn $scope.data.uploads && $scope.data.uploads[path];\n\t};\n\n\t$scope.sumFiles = function(t) {\n\t\treturn t.files ? t.files.reduce(function(s, f) { return s+f.length; }, 0) : 0;\n\t};\n\n\t$scope.previews = {};\n\t$scope.ext = function(path) {\n\t\treturn (/\\.([^\\.]+)$/).test(path) ? RegExp.$1 : null;\n\t};\n\n\tvar ws;\n\t//websocket keep alive\n\tsetInterval(function() {\n\t\tif (ws && ws.readyState === window.WebSocket.OPEN)\n\t\t\tws.send(\"ping\");\n\t}, 30 * 1000);\n\t//websocket auto reconnect\n\t(function reconnect() {\n\n\t\t//reset backoff timer\n\t\tif(!reconnect.t) \n\t\t\treconnect.t = 100;\n\n\t\tvar url = window.location.origin.replace(\"http\", \"ws\");\n\t\tws = new window.WebSocket(url);\n\t\tws.onmessage = function(e) {\n\t\t\tif (e.data === \"ping\") return;\n\t\t\tvar data = JSON.parse(e.data);\n\t\t\tmerge($scope.data, data);\n\t\t\t$scope.$apply();\n\t\t};\n\t\tws.onerror = function(err) {\n\t\t\t//noop\n\t\t};\n\t\tws.onopen = function() {\n\t\t\tconsole.log(\"connected\");\n\t\t\t$scope.$apply(function() {\n\t\t\t\t$scope.connected = true;\n\t\t\t});\n\t\t\treconnect.t = 100;\n\t\t};\n\t\tws.onclose = function() {\n\t\t\t$scope.$apply(function() {\n\t\t\t\t$scope.connected = false;\n\t\t\t});\n\t\t\treconnect.t *= 2;\n\t\t\tsetTimeout(reconnect, reconnect.t);\n\t\t\tconsole.log(\"disconnected, reconnecting in %sms\",reconnect.t);\n\t\t};\n\t})();\n});","/home/travis/build/npmtest/node-npmtest-torrent-cloud/node_modules/torrent-cloud/lib/backends/_template.js":"\n//this backend will be used if *all* of these env 'vars' are present\nexports.vars = [\"MY_VAR_1\", \"MY_VAR_2\"];\n\n//if these 'vars' are present, 'init' will be called on module load\nexports.init = function(config) {\n\tconfig.MY_VAR_1\n};\n\n//upload will be called to upload a downloading torrent file\nexports.upload = function(torrentFile, callback) {\n\t//torrentFile is an object, with properties:\n\t//\tpath - string\n\t//\tlength - length of file (IMPORTANT: when zipping all files,\n\t// \t\t\twe don't know exact length, so always try to use multipart uploads where length\n\t//\t\t\tis not required, else buffer the file)\n\t//\tcreateReadStream - function() begins to download file, returns a stream object\n\t//\t\t\t\t\t\tyou must handle the \"error\" event!\n\t//\t\t\t\t(note: stream staggered to prevent backlog from slow uploads)\n\t\n\t//callback when stream has been fully uploaded\n\tcallback(null);\n};\n\n//list will be called to list all stored files\nexports.list = function(callback) {\n\tcallback(null, {\n\t\t//original path to file (torrentFile.path)\n\t\t\"path1\": {\n\t\t\tlength: 0, //total length of file in bytes\n\t\t\turl: \"\" //public url to file\n\t\t},\n\t\t\"path2\": {\n\t\t\t//...\n\t\t}\n\t});\n};\n\n//removes a file at the given path (will be torrentFile.path)\nexports.remove = function(path, callback) {\n\tcallback(null);\n};"}